<!doctype html>
<meta name="timeout" content="long">
<title>Confirm close event is not fired when the page enters BFCache and MessagePort still works after the page is restored</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/dispatcher/dispatcher.js"></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="/common/utils.js"></script>
<script src="/html/browsers/browsing-the-web/remote-context-helper/resources/remote-context-helper.js"></script>
<script src="/service-workers/service-worker/resources/test-helpers.sub.js"></script>

<script>
promise_test(async t => {
  // Register a service worker.
  const scope =
      '/html/browsers/browsing-the-web/remote-context-helper/resources'
  const workerUrl =
      `resources/service-worker.js?pipe=header(Service-Worker-Allowed,${
          scope})`;
  const registration =
      await service_worker_unregister_and_register(t, workerUrl, scope);
  t.add_cleanup(_ => registration.unregister());
  await wait_for_state(t, registration.installing, 'activated');

  // Open a window with noopener so that BFCache will work.
  const rcHelper = new RemoteContextHelper();
  const rc1 = await rcHelper.addWindow(
      /*extraConfig=*/ null, /*options=*/ {features: 'noopener'});

  // Confirm the page is controlled.
  assert_true(
      await rc1.executeScript(
          () => (navigator.serviceWorker.controller !== null)),
      'The page should be controlled before navigation');

  // Send MessagePort to the service worker.
  await rc1.executeScript(() => {
    const {port1, port2} = new MessageChannel();
    port1.start();
    const ctrl = navigator.serviceWorker.controller;
    ctrl.postMessage({type: 'storeMessagePort'}, [port2]);
    self.waitForMessage = (sentMessage) => {
      return new Promise(resolve => {
        port1.addEventListener('message', (event) => {
          resolve(event.data);
        });
        port1.postMessage(sentMessage);
      });
    };
    window.addEventListener('pageshow', e => {
      window.pageshowEvent = e;
    });
  });

  // Navigate away to let page enter BFCache.
  const rc2 = await rc1.navigateToNew();

  // Navigate back.
  await rc2.historyBack();

  // Verify that the page was BFCached.
  assert_true(await rc1.executeScript(() => {
    return window.pageshowEvent.persisted;
  }));

  // Confirm MessagePort can still work after the page is restored from
  // BFCache.
  assert_equals(
      await rc1.executeScript(
          async () =>
              await self.waitForMessage('Confirm the ports can communicate')),
      'Receive message');

  // Confirm the close event was not fired.
  assert_false(await rc1.executeScript(
      async () =>
          await self.waitForMessage('Ask if the close event was fired')));
}, 'MessagePort still works after the page is restored from BFCache');
</script>